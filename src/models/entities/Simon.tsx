/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import { BoxGeometryProps } from "@react-three/fiber";
import { RigidBody } from "@react-three/rapier";
import { useGame } from "ecctrl";
import React, { useEffect, useMemo, useRef } from "react";
import { AnimationClip, Group, Vector3 } from "three";
import { GLTF, SkeletonUtils } from "three-stdlib";

interface ISimonProps {
    isPlayer?: boolean;
    colliderPosition?: Vector3;
    colliderBoxArgs?: BoxGeometryProps["args"];
}
export const Simon = ({
    isPlayer = false,
    colliderPosition = new Vector3(0, 0, 0),
    colliderBoxArgs = [ 0.5, 1.5, 1 ],
    ...props
}: React.JSX.IntrinsicElements["group"] & ISimonProps) => {
    const group = useRef<Group>(null);

    const { scene, animations } = useGLTF("/models/entities/simon.glb") as GLTFResult;
    const clone = useMemo(() => SkeletonUtils.clone(scene), [ scene ]);

    const { actions } = useAnimations(animations, group);

    const curAnimation = useGame(state => state.curAnimation) as TActionName;
    const resetAnimation = useGame(state => state.reset);
    const initializeAnimationSet = useGame(state => state.initializeAnimationSet);

    const animationSet = useMemo(() => {
        return {
            idle: "Idle",
            walk: "Walk",
            run: "Run",
            jump: "",
            jumpIdle: "",
            jumpLand: "",
            fall: "Fall",
        };
    }, []);

    useEffect(() => {
        if (isPlayer && initializeAnimationSet) {
            initializeAnimationSet(animationSet);
        }
    }, [ animationSet, initializeAnimationSet, isPlayer ]);

    useEffect(() => {
        if (group.current && isPlayer) {
            group.current.traverse(child => {
                child.layers.set(2);
            });
        }
    }, [ isPlayer ]);

    useEffect(() => {
        if (isPlayer) return;
        actions.Sitting_idle && actions.Sitting_idle.play();
    }, [ actions.Sitting_idle, isPlayer ]);

    useEffect(() => {
        if (!isPlayer) return;
        const action = actions[curAnimation || animationSet.idle];

        if (!action) return;

        action.reset().fadeIn(0.2).play();

        action.getMixer().addEventListener("finished", resetAnimation);


        return () => {
            action.fadeOut(0.2);
            action.getMixer().removeEventListener("finished", resetAnimation);

        };
    }, [ curAnimation, actions, animationSet, resetAnimation, isPlayer ]);

    return (
        <>
            {!isPlayer ? (
                <RigidBody type="fixed" position={colliderPosition} includeInvisible={true}>
                    <mesh visible={false}>
                        <boxGeometry args={colliderBoxArgs} />
                    </mesh>
                </RigidBody>
            ) : null}
            <primitive ref={group} object={clone} {...props} />
        </>
    );
};

type TActionName = "Fall" | "Idle" | "Jump" | "Run" | "Sitting_idle" | "T-Pose" | "Walk";

interface IGLTFAction extends AnimationClip {
    name: TActionName;
}

type GLTFResult = GLTF & {
    animations: IGLTFAction[];
};

useGLTF.preload("/models/entities/simon.glb");
